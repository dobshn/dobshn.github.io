**비트코인:** 금융 기관을 거치지 않고 한 당사자로부터 다른 당사자에게 직접 돈을 보낼 수 있도록 하는 P2P 시스템

코인을 다른 소유자에게 전달하는 방법
- (이전 거래의 해시 + 다음 소유자의 공개 키) 위에 전자 서명함

거래가 모여 블록을 이룬다
블록이 이어져 체인이 된다
- 새로운 블록이 생성될 때, 블록은 이전 블록의 해시를 포함한다

연속적인 작업 증명(Proof-of-Work) 체인
- 한 거래 내역을 바꾸려면, 그 거래가 포함된 블록의 넌스를 새로 찾아야 한다.
- 그 블록이 바뀌면, 그 다음 블록에 있는 이전 블록의 해시가 바뀌어 또 넌스를 찾아야 한다.
- 그 다음 블록도 마찬가지이다.

---
### 0. Abstract

순수한 peer-to-peer electronic cash는 금융 기관을 거치지 않고 다른 개인에게 돈을 보낼 수 있다

이때 double-spending 문제를 해결하기 위해 제 3자를 활용한다면, 이러한 장점이 사라진다.

double-spending 문제란, 하나의 코인을 두 번 이상 사용하는 문제이다.

bitcoin에선 double-spending 문제를 peer-to-peer network로 해결한다. 이 체인은 작업 증명된 연속적인 블록들로 이루어져 있어, 수정하려면 해당 블록과 이후 모든 블록에 대한 작업 증명을 재시도해야한다. 이는 막대한 컴퓨팅 자원을 요구하는 작업이다.

따라서 CPU 자원의 과반이 정상적인 사용자들에 의해 통제된다면, 이 체인이 악의적인 체인보다 항상 앞서게 된다.

---
### 1. Introduction

오늘날 인터넷상 거래는 금융기관을 신뢰하는 제3자로 삼아 이루어진다. 이는
- 비가역적인(되돌릴 수 없는) 거래를 불가능하게 하고,
- 중개 수수료로 인해 최소 거래 비용을 증가시키
는 문제가 있다.

신뢰가 아닌 cryptographic proof에 기반한 전자 결제 시스템을 만들고자 한다.

이때 등장하는 double-spending 문제에 대한 해법으로 distributed timestamp server를 제안한다.

---
### 2. Transactions

비트코인에서 코인은, 연속된 디지털 서명이다.

double-spending을 막기 위해 모든 노드가 동의하는 공개된 거래 내역이 존재해야 한다. 이를 통해 새로 들어온 거래가 최초의 거래임을 증명할 수 있다.

---
### 3. Timestamp Server

double-spending 문제에 대한 해법으로 timestamp server 방식을 차용한다.

timestamp server는 항목들을 블록 단위로 묶어 현재 블록과 이전 블록의 해시값을 해싱하여 공개적으로 출판한다.

각 타임스탬프는 이전 타임스탬프의 해시를 포함하기 때문에, 타임스탬프가 추가될 때마다 이전 타임스탬프들의 보안성이 강화된다.

---
### 4. Proof-of-Work

peer-to-peer timestamp server를 구현하기 위해, Adam Back의 Hashcash와 유사한 proof-of-work를 사용한다.

작업 증명(proof-of-work)는 nonce 값을 변경하며 해시했을 때, 해시 값이 특정 개수의 leading 0를 가지도록 하는 과정이다. 이러한 nonce를 찾는 것은 많은 컴퓨팅 자원이 필요하다. 반면 이를 검증하는 것은 단 한번의 해싱으로 가능하다.

이러한 nonce 값을 찾은 블록만 체인에 연결될 수 있다. 따라서 가장 긴 체인은 곧 가장 많은 연산 자원을 의미한다.

---
### 5. Network

1. 새로운 트랜젝션은 모든 노드에 브로드캐스트된다.
2. 각 노드들은 새로운 트랜젝션들을 모아 블록을 만든다.
3. 블록이 되기 위해선 작업 증명(proof-of-work)이 필요하다. 이를 위해 연산을 수행한다.
4. 블록에 대한 작업 증명을 찾았다면, 그 블록을 모든 노드에 브로드캐스트한다.
5. 새로운 블록을 받으면 그 블록에 속한 모든 트랜잭션이 유효하고 이미 소비되지 않았는지 검사한다.
6. 문제가 없으면 새로 받은 블록의 해시를 이전 블록의 해시로 삼아 다음 블록을 만듦으로써 수락을 표한다.

**한 블록의 트랜젝션 수**
- 최소 1개의 제한이 있고, 최대 제한은 블록 크기(용량)로 결정된다.
- 채굴자는 막대한 연산 자원을 투자하는 만큼 보상이 필요하다. 이는 트랜젝션을 블록에 포함시키면 받는 수수료이다. 따라서 채굴자는 한 번에 최대한 많은 트랜젝션을 담아 블록을 만들고자 한다.

작업 증명 찾기는 경쟁이다. 내가 특정 블록에 대한 작업 증명을 열심히 찾고 있는 중에 다른 누군가가 새로운 블록을 채굴했다면, 내 블록에 "이전 블록 해시" 값이 바뀌기 때문에 처음부터 작업해야한다.

**노드는 어떻게 블록을 검증할까?**
- 우선 블록 자체의 무결성을 검증한다. 블록 헤더를 보며 작업 증명이 정상적인지 등을 검사한다.
- 이후 블록에 포함된 트랜잭션들을 검증한다.

**블록이 누락되는 경우**
- A -> B -> C로 이어지는 블록 체인이 있을 때, 나는 A까지만 보유하고 있다고 하자. 이때 C를 받게 되면 체인이 이어지지 않는다. 따라서 주변 노드에게 B를 요청해 받는다.
- *이 방식이라면 새로 받은 블록의 이전 블록 해시 값이 유효하지 않은 것인지 어떻게 구분하지?*

---
### 6. Incentive

**블록을 채굴하면 새로운 코인을 얻는다**
- 전통적으로 블록의 첫 번째 트랜잭션은 블록 생성자가 획득하는 새로운 코인으로 시작한다. 이것은 다음과 같은 효과를 갖는다.
	- 채굴자가 블록의 작업 증명을 찾을 동기가 된다. 작업 증명은 자원(CPU, 전력)을 소비하는 행위이기 때문에 동기가 필요하다.
	- 생태계에 코인이 생성되는 계기가 된다. 중앙 통제 기관이 없으므로 코인을 발행할 수 없기 때문에 이 방법을 통해 코인이 생성되도록 한다.

**트랜잭션 수수료**
- 또한 채굴자는 트랜잭션들의 수수료도 획득한다. 수수료는 트랜잭션의 입력과 출력의 차액이다. 예를 들어, 입력이 1.2 BTC이고 출력이 1.1 BTC라면, 0.1 BTC가 수수료가 된다.
- 생태계에 충분한 수의 화폐가 채굴을 통해 발행되었다면, 더 이상 새로운 코인이 생성되지 않도록 할 수 있다. 이 경우 오로지 트랜잭션 수수료만이 인센티브가 된다.

**인센티브는 공격자가 정직하게 행동하도록 한다**
- Bitcoin에서 double-spending을 하려면 50% 이상의 CPU 파워를 가져야 한다. 하지만 그만큼의 CPU 파워를 갖고 있다면, 새로운 블록을 채굴해 수수료를 얻을 수 있다. 따라서 double-spending 과 같은 공격을 통해 단발적인 이익만 보고 bitcoin 자체의 신뢰를 잃는 것보다, 시스템을 유지한 채로 수수료를 버는 것이 낫기 때문이다.

---
### 7. Reclaiming Disk Space
디스크 공간 확보하기

블록에는 모든 트랜잭션들이 포함된다. 따라서 용량이 클 수 있다. 하지만 80-byte 밖에 되지 않는 블록 헤더에 블록에 포함된 트랜잭션들의 머클 루트가 포함된다. 따라서 블록 헤더만을 저장하는 것으로 무결성을 보장할 수 있다.

블록은
- 블록 헤더
- 트랜잭션들
로 이루어져 있다. 하지만 블록의 해시 값은 블록 헤더의 해시 값이다. 따라서 블록에서 트랜잭션을 제거하더라도 블록 해시 값이 변하진 않는다. 블록 헤더에 트랜잭션들의 머클 루트가 있기 때문에 트랜잭션의 무결성도 동시에 보장된다.

블록이 10분에 한 개씩 생성된다고 가정했을 때, 80-byte * 6 * 24 * 365 = 4.2MB per year 밖에 되지 않는다. 따라서 충분히 저장 가능한 수준이다.

---
### 8. Simplified Payment Verification

전체 블록을 검증하지 않고, 특정 거래가 블록에 포함되었는지 검증할 수 있다. 이것을 SPV라고 한다.

이를 위해선 가장 긴 Proof-of-Work 체인이 필요하다. 여기에는 블록의 헤더들만 있다.

검증하고자 하는 블록의 머클 루트를 통해 특정 거래가 포함되었는지를 검증한다. 이를 위해 머클 루트까지 가는 경로의 해시 값들인 머클 브랜치가 필요하다. 이를 다른 노드들을 통해 전파받는다.

*SPV 노드가 풀 노드에 비해 공격에 취약하다는 점은 이해하지 못했다. 또한 유효하지 않은 블록에 대해 경고를 보내는 시스템도 마찬가지이다.*

---
### 9. Combining and Splitting Value

하나의 트랜잭션에는 여러 입력이 있을 수 있다. 출력은 대부분 두 개이다. 하나는 수신자, 다른 하나는 잔돈이다.

예를 들어, A는 B에게 1.5 BTC를 송금하고자 한다. 0.6 BTC와 1.3 BTC를 합쳐 1.9 BTC를 쓸 수 있다. 이때 1.5 BTC는 B에게, 나머지 0.3 BTC는 자신에게 돌릴 수 있다. 이때 0.1 BTC는 트랜잭션 수수료가 된다.

---
### 10. Privacy

전통적인 은행 모델에서의 프라이버시는 은행이 사용자에게 정보를 어느 정도 공개할지 결정함으로써 보호될 수 있다.

반면 Bitcoin에선 모든 트랜잭션이 공개되어야 한다. 그럼에도 공개 키를 익명으로 둠으로써 프라이버시를 보장한다.

누군가가 특정 금액을 다른 누군가에게 전송한다는 정보는 공개되지만, 그 각각이 누구인지는 알 수 없는 구조다. 이는 마치 주식 거래와 유사하다. 누군가 얼마만큼의 주식을 거래했다는 것은 알지만, 그게 누구인지 모르는 것 처럼.

프라이버시를 강화하기 위해서 각 사용자는 매 거래 때마다 새로운 공개 키를 사용해야한다. 그렇지 않으면 특정 공개키로 트랜잭션들이 엮일 수 있기 때문이다.

다만 한 트랜잭션의 여러 입력들에 대한 공개 키가 한 사람을 가리킨다는 연결마저 끊을 순 없다. 이런 경우 하나의 공개 키가 특정될 경우 같이 사용된 다른 공개 키도 같은 사람이라는 정보가 유출될 순 있다.

---
### 11. Calculations

공격자가 하는 일은 double-spending이다. 즉, 특정 코인을 두 명 이상에게 보내고 이들 중 하나의 트랜잭션만 포함된 블록체인을 빠르게 만들어 나머지 하나의 트랜잭션이 무효가 되도록 하는 것이다. 새로운 코인을 만들어내거나 다른 사람의 코인을 뺏는 행위를 하는 것이 아니다.

정직한 체인과 공격자의 체인간의 경쟁은 Binomial Random Walk의 특징을 갖는다. 새로운 블록이 발견되었을 때 그것이 정직한 노드에 의한 블록일 확률 $p$와 공격자 노드에 의한 블록일 확률 $q$에 따라 결정된다. 정직한 노드에 의한 것이면 격차가 1 증가하고, 공격자 노드에 의한 것이면 격차가 1 감소한다.

$q_z$를 공격자가 $z$ 격차로 뒤쳐지고 있을 때 언젠가 정직한 체인을 따라잡을 확률이라고 한다면,

$$
q_z = \begin{cases} 1 & \text{if } p \leq q \\ (q/p)^z & \text{if } p > q \end{cases}
$$

처럼 나타낼 수 있다. 즉, 공격자가 채굴할 확률이 더 높다면 언젠가 무조건 따라잡을 것이고, 정직한 노드가 채굴할 확률이 더 높다면 $(q/p)^z$의 확률로 따라잡을 것이다. 따라서 격차가 증가할 때마다 따라잡을 확률은 기하급수적으로 감소하게 된다.

방금까지의 계산은 정직한 체인과 공격자 체인의 격차가 $z$개의 블록일 때, 공격자의 체인이 정직한 체인보다 길어질 확률을 계산한 것이다.

지금부터는 트랜잭션의 수신자가 해당 트랜잭션이 포함된 블록 이후에 몇 개의 블록이 추가되어야 확정지을 수 있을지에 대한 계산을 한다.

우선 거래의 수신자는 송신자에게 자신의 공개 키를 전송해야 한다. 하지만 이는 최대한 미뤄야한다. double-spending의 핵심은 정상 거래로부터 브랜치 된 악의적인 브랜치가 존재하고, 이것이 정상 브랜치보다 길 때 악의적인 브랜치가 정상 브랜치를 대체하는 것이다. 공격자가 악의적인 브랜치를 아무리 만들고 있더라도, 정상 거래가 포함된 블록 이후의 블록에서 앞서나가야한다. 만일 공격자가 수신자의 공개 키를 미리 알고 있다면, 트랜잭션을 미리 생성해두어 정상적인 거래 브랜치를 생성해놓고, 악의적인 브랜치를 미리 만들어둘 수 있다. 따라서 수신자는 거래 시점에 자신의 새로운 공개키를 송신자에게 알려야한다.

거래가 포함된 블록이 추가되고 $z$개의 블록이 이어지는 동안 공격자의 악의적인 체인에 추가되었을 블록 수는 다음과 같이 나타낼 수 있다.

$$
\lambda = z \cdot \frac{q}{p}
$$

예를 들어, 정직한 노드가 블록을 찾을 확률이 70%이고, 공격자가 블록을 찾을 확률이 30%일 때 정직한 블록이 6개가 추가되었다면, $p = 0.7$, $q = 0.3$, $z = 6$ 이므로 공격자는 평균 $\lambda = 6 \cdot \frac{0.3}{0.7} \approx 2.57$개의 블록을 악의적인 체인에 쌓는다.

공격자가 k개의 블록을 만들었을 확률은 다음과 같다:

$$
\frac{\lambda^k e^{-\lambda}}{k!}
$$

$k$는 공격자가 만든 블록의 수이고, $z$는 정직한 블록의 수이다. 따라서 공격자가 정직한 체인을 따라잡을 확률은 다음과 같다:

$$
\begin{cases} (q/p)^{(z-k)} & \text{if } k \leq z \\ 1 & \text{if } k > z \end{cases}
$$

공격자의 최종 성공 확률은 "공격자가 k개의 블록을 만들었을 확률" x "그 상태에서 따라잡을 확률"이므로,

$$
\sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot
\begin{cases}
\left(\dfrac{q}{p}\right)^{z-k} & \text{if } k \leq z
1 & \text{if } k > z
\end{cases}
$$

이다. 이 식에서 무한합을 제거하면 다음과 같이 표현할 수 있다:

$$
1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!}\Big(1 - \left(\tfrac{q}{p}\right)^{z-k}\Big)
$$

이를 C 코드로 변환하면 다음과 같다:
```c
#include <math.h>
double AttackerSuccessProbability(double q, int z)
{
	double p = 1.0 - q;
	double lambda = z * (q / p);
	double sum = 1.0;
	int i, k;
	for (k = 0; k <= z; k++)
	{
		double poisson = exp(-lambda);
		for (i = 1; i <= k; i++)
			poisson *= lambda / i;
		sum -= poisson * (1 - pow(q / p, z - k));
	}
	return sum;
}
```

최종적으로 공격에 성공할 확률이 0.1%보다 작아지는 z값을, 공격자가 차지한 CPU 파워 `q`에 따라 구하면 다음과 같다:
```
q=0.10 z=5
q=0.15 z=8
q=0.20 z=11
q=0.25 z=15
q=0.30 z=24
q=0.35 z=41
q=0.40 z=89
q=0.45 z=340
```

---
### 12. Conclusion

이 논문은 신뢰하는 제 3자가 필요하지 않은 전자 거래 시스템을 제안했다.

기존 전자 서명을 활용한 화폐 시스템은 제 3자를 도입하지 않고서는 double-spending 문제를 해결하지 못했다. Bitcoin은 proof-of-work를 사용하는 peer-to-peer 네트워크를 통해 double-spending을 방지한다. 이 시스템에선 과반 이상의 CPU 파워를 정직한 사용자들이 가지고 있다면, 공격자가 블록 체인을 수정하는 것이 거의 불가능하다.

노드들은 자유롭게 시스템에 참여했다 떠날 수 있다. 다시 복귀할 때는 그동안 생성된 작업 증명 체인을 받아들임으로써 가능하다.

노드들은 자신의 CPU 파워를 사용해 투표한다. 즉, 잘못된 블록에 대해선 그 블록을 잇는 블록을 생성하지 않고, 옳은 블록에 이어지는 작업 증명을 찾음으로써 블록에 대한 수락 의사를 표한다.

---
### Comments

**논문을 읽게된 배경**
- 나는 평소 암호학을 활용한 무결성 검증 및 사용자 인증 시스템에 흥미가 있었다. Udemy의 Crypto 강의에서 마지막 주제로 block chain을 다루었는데, 암호학을 활용한 시스템의 결정체처럼 느껴졌다.
- 그 중에서도 오늘날 매우 유명한 bitcoin의 등장 배경이 매우 흥미로웠다. 익명의 연구자가 기재한 논문이 출발점이라는 것이다. 오늘날 bitcoin의 파급력을 생각했을 때, 그 출발점이 되는 논문이 궁금하지 않을 수 없었다.

**읽고 난 소감**
- 돈은 신용이라 할 수 있다. 암호학적 기법은 특정 데이터에 대한 소유권을 증명한다. 이러한 신용을 바탕으로 화폐를 구축하는 것이 흥미로웠다.
- 동시에 공개 키 알고리즘은 근본적으로 계산의 어려움에 뿌리를 두기 때문에, 양자 컴퓨팅 시대에 bitcoin이 신용을 잃는다는 것이 자연스럽게 이해되었다. 소유권을 증명하는 것이 개인 키를 아는 사람만 계산이 가능한 것이 핵심인데, 양자 컴퓨팅은 개인 키를 알지 못하더라도 다항 시간 내에 계산이 가능해지기 때문이다.
- 11. Calculation 절에서 수식을 코드로 해석하는 부분이 인상적이었다. 인간이 사고하고, 계산은 컴퓨터에게 맡기는 것이 컴퓨터의 근원적 존재이유임을 일깨워주는 부분이었다. 이러한 사고를 컴퓨터에게 입력하는 과정이 "코딩"임도 느껴졌다.
- bitcoin을 실습해보고 싶다는 마음이 든다. 실제로 트랜잭션을 생성도 해보고, 블록도 생성해보고 싶다.
